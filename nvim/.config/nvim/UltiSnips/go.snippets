# Fmt Printf debug
snippet ff "fmt.Printf(...)"
fmt.Printf("$1 = %+v\n", ${1:${VISUAL}})
endsnippet

# Fmt Println debug
snippet fn "fmt.Println(...)"
fmt.Println("${1:${VISUAL}}")
endsnippet

# log printf
snippet lf "log.Printf(...)"
log.Printf("${1:${VISUAL}} = %+v\n", $1)
endsnippet

# log println
snippet ln "log.Println(...)"
log.Println("${1:${VISUAL}}")
endsnippet

# main()
snippet main "func main() { ... }"
func main() {
	${0:${VISUAL}}
}
endsnippet

# switch
snippet switch "switch x { ... }"
switch ${1:var} {
case ${2:value1}:
	${0}
}
endsnippet

# sprintf
snippet sp "fmt.Sprintf(...)"
fmt.Sprintf("%${1:s}", ${2:var})
endsnippet

# test function
snippet test "func TestXYZ(t *testing.T) { ... }"
func Test${1:Function}(t *testing.T) {
	${0:${VISUAL}}
}
endsnippet

# test table snippet
snippet tt
var tests = []struct {
	name string
	expected string
	given string
}{
	{"${1}", "${2}", "${3}",},
}
for _, tt := range tests {
	tt := tt
	t.Run(tt.name, func(t *testing.T){
		actual := ${0:${VISUAL}}(tt.given)
		if actual != tt.expected {
				t.Errorf("$0(%s): expected %s, actual %s", tt.given, tt.expected, actual)
		}

	})
}
endsnippet

# ctx context.Context
snippet ctx "ctx context.Context" w
ctx context.Context
endsnippet

snippet ifok "If ok then" b
if ${2:v}, ok := ${1}; ok {
	${0:${VISUAL}}
}
endsnippet

snippet rpchandler "Orion service method definition" b
func ($1 $2) $3(ctx context.Context, req *proto.$3Request) (*proto.$3Response, error) {
	resp := &proto.$3Response{}
	$4
	return resp, nil
}
endsnippet

snippet testcases "table tests struct" b
cases := []struct {
	$1
}{
	{},
}

for _, c := range cases {

}
endsnippet

snippet spew "spew.Dump" b
spew.Dump($1)
endsnippet

snippet createrule "Trust service create rule" b
state.CreateRule(Rule{
	Name: "",
	Func: func(state *State) bool {
		return false
	},
	RolloutPercent: 0,
	Reason:         "",
})
endsnippet

snippet whenrule "Trust service when rule" b
state.WhenRule([]string{
	""
},
	NewLabelAction("label_name", CreatedContentLabelTarget, PendingLabelState),
)
endsnippet

snippet ffjson "Parse to json and print" b
b, _ := json.Marshal($1)
fmt.Println(string(b))
endsnippet

# test table snippet
snippet tt
var tests = []struct {
	name string
	given string
	expected string
}{
	{
		"${1}",
		"",
		"",
	},
}
for _, tt := range tests {
	tt := tt
	t.Run(tt.name, func(t *testing.T){
		result := ${0:${VISUAL}}(tt.given)
		if result != tt.expected {
			t.Errorf("$0(%+v): expected %+v, got %+v", tt.given, tt.expected, result)
		}

	})
}
endsnippet

snippet trun "t.Run()" b
t.Run("$1", func(t *testing.T) {
})
endsnippet

snippet span "spanutils" b
span, ctx := spanutils.NewInternalSpan(ctx, "$1")
defer span.Finish()
endsnippet

# error snippet
snippet errn "Error return" !b
if err != nil {
	return err
}
${0}
endsnippet

snippet errnw "Error return wrap" !b
if err != nil {
	return errors.Wrap(err, "${1:message}")
}
${0}
endsnippet

# error log snippet
snippet errl "Error with log.Fatal(err)" !b
if err != nil {
	log.Fatal(err)
}
${0}
endsnippet

# error multiple return
snippet errn, "Error return with two return values" !b
if err != nil {
	return ${1:nil}, ${2:err}
}
${0}
endsnippet

snippet errn,w "Error return wrap with two return values" !b
if err != nil {
	return nil, errors.Wrap(err, "${1:message}")
}
${0}
endsnippet

# error panic
snippet errp "Error panic" !b
if err != nil {
	panic(${1})
}
${0}
endsnippet

# for loop
snippet for "for ... { ... }"
for ${1} {
	${0:${VISUAL}}
}
endsnippet

# for integer loop
snippet fori "for 0..N-1 { ... }"
for ${1:i} := 0; $1 < ${2:N}; $1++ {
	${0:${VISUAL}}
}
endsnippet

# for range loop
snippet forr "for k, v := range items { ... }"
for ${2:k}, ${3:v} := range ${1} {
	${0:${VISUAL}}
}
endsnippet

# append
snippet ap "append(slice, value)"
append(${1:slice}, ${0:value})
endsnippet
